# application-collector.yml
spring:
  # run as a non-web process (no Tomcat)
  main:
    web-application-type: none
    banner-mode: off

  datasource:
    url: jdbc:postgresql://127.0.0.1:5432/homewatts_cache
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}

  # turn ON scheduling for the collector
  task:
    scheduling:
      enabled: true
      pool:
        size: 1
      execution:
        shutdown:
          await-termination: true
          await-termination-period: 30s
          
  # the collector shouldn't run Flyway migrations; let the backend own them
  flyway:
    enabled: false

cache:
  datasource:
    url: jdbc:postgresql://127.0.0.1:5432/homewatts_cache
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}

# minimal actuator on its own port so compose can healthcheck it
management:
  server:
    port: 8081
  endpoints:
    web:
      exposure:
        include: health
  endpoint:
    health:
      show-details: "never"   # avoid leaking DB details in health

# keep logging modest in the worker
logging:
  level:
    root: INFO
    com.pvmanagement: INFO
    org.springframework.security: WARN
    org.hibernate.SQL: WARN
    org.hibernate.type.descriptor.sql: WARN

# optional feature flag if you guarded your collector code with @ConditionalOnProperty
ingestion:
  enabled: true
